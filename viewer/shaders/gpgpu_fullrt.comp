#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform int refractions;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

struct Pt_t {
    vec4 origin;
    vec4 dir;
    vec3 pt_hit;
    vec4 normal;
    vec4 color;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

/*
* This function calculates the ambiant component of the Blinn-Phong model for lighting
*/
vec4 ambiant(vec4 color, float ka){
    return color*ka*lightIntensity;
}

/*
*This function calculates max(V1.V2,0), where V1 and V2 are both vec4 vectors.
*/
float max_scalar_zero(vec4 V1, vec4 V2) {
    float res = max(dot(V1,V2),0);
    return res;
}

/*
* This function calculates the diffuse component of the Blinn-Phong model for lighting
*/
vec4 diffuse(vec4 color,vec4 normal,vec4 LightVector, float kd){
    return color*max_scalar_zero(normal,LightVector)*kd*lightIntensity;
}

/*
* This function calculates the Fresnel coefficient
*/
float fresnel_coeff(float cost){
    float ci = abs(eta*eta + 1 - cost*cost) ;
    ci = sqrt(ci);
    float nume = cost - ci;
    float denom = cost + ci;
    float Fs = abs(nume/denom);
    Fs = Fs*Fs;
    nume = eta*eta*cost - ci;
    denom = eta*eta*cost + ci;
    float Fp = abs(nume/denom);
    Fp = Fp * Fp;
    return((Fs+Fp)/2);
  }

/*
* This function calculates the specular component of the Blinn-Phong model for ligthing
*/
vec4 specular_blinn(vec4 color, vec4 normal,vec3 toLightSource,vec4 direction){
    vec4 H = vec4(normalize(toLightSource-direction.xyz),1);
    float cost = dot(H,vec4(toLightSource,1));
    float F = fresnel_coeff(cost);
    float max = max_scalar_zero(normal,H);
    max = pow(max,shininess);
    return ( F*max* color *  lightIntensity);
}

bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec4 Pmin = vec4(bbmin,1);
    vec4 Pmax = vec4(bbmax,1);
    vec4 tmin = Pmin - origin;
    tmin = tmin / dir;
    vec4 tmax = Pmax - origin;
    tmax = tmax / dir;
    vec4 minimum = min(tmax,tmin);
    vec4 maximum = max(tmax,tmin);
    float In = max(minimum.x,minimum.y);
    In = max(In,minimum.z);
    float Out = min(maximum.x,maximum.y);
    Out = min(Out,maximum.z);
    return (Out > In);
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
    vec4 e1 = vertices[indices[ptr+1]] - vertices[indices[ptr]] ;
    vec4 e2 = vertices[indices[ptr+2]] - vertices[indices[ptr]];
    vec4 t = origin - vertices[indices[ptr]];
    vec3 p_3 = cross(dir.xyz,e2.xyz);
    vec3 q_3 = cross(t.xyz,e1.xyz);
    vec4 p = vec4(p_3,0.0);
    vec4 q = vec4(q_3,0.0);
    float a = dot(p,e1);
    if (a > -EPS && a < EPS) {
        return false;
    }
    float coef = 1/a;
    float alpha = coef * dot(p,t);
    if (alpha < 0.0 || alpha > 1.0) {
        return false;
    }
    float beta = coef * dot(q,dir);
    if (beta < 0.0 || beta+alpha > 1.0) {
        return false;
    }
    float lambda = coef * dot(q,e2);
    if (10000.0 > lambda && lambda > EPS) {
        dist = vec4(alpha,beta,1-alpha-beta,lambda);
        return true;
    } else {
        return false;
    }
}

bool intersectGround(vec4 origin, vec4 dir, out float lambda) {
    vec4 normal = vec4(0.0,1.0,0.0,0.0);
    vec4 PQ = vec4(0.0,-groundDistance,0.0,1.0) - origin;
    float denom = dot(dir,normal);
    if (abs(denom) < EPS) {
        return false;
    }
    float lambda_temp = dot(PQ,normal) / denom;
    vec4 Point = origin + lambda_temp * dir;
    // on se restreint à un plan circulaire de rayon radius
    if (lambda_temp > EPS && sqrt(Point.x*Point.x + Point.z*Point.z) < radius*MAX_SCENE_BOUNDS) {
        lambda = lambda_temp;
        return true;
    }
    lambda = 10000.0;
    return false;
}

vec4 interpolateNormal(hitinfo_t h)
{
    vec4 n0 = normals[indices[h.hit_vptr]];
    vec4 n1 = normals[indices[h.hit_vptr+1]];
    vec4 n2 = normals[indices[h.hit_vptr+2]];
    return h.t.z*n0+h.t.x*n1+h.t.y*n2;

}

vec4 interpolateColor(hitinfo_t h)
{
    vec4 colV0 = colors[indices[h.hit_vptr]];
    vec4 colV1 = colors[indices[h.hit_vptr+1]];
    vec4 colV2 = colors[indices[h.hit_vptr+2]];
	return h.t.z*colV0+h.t.x*colV1+h.t.y*colV2;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
    float lambda; // stores the lambda value when there is a hit on the ground
    bool hit = false;
    vec4 normal = vec4(0.0,1.0,0.0,0.0);
    h.t.w = radius * MAX_SCENE_BOUNDS;
    if(intersectBoundingBox(origin, dir)) {
        for(int j = 0; j < indices.length(); j += 3) {
            if(intersectTriangle(origin, dir, j, dist)) {
                hit = true ;
                if(dist.w<h.t.w){
                    h.t = dist;
                    h.hit_vptr = j;
                }
            }
        }
        if (intersectGround(origin,dir,lambda)) {
            if (intersectTriangle(origin,dir,h.hit_vptr,dist) && h.t.w < lambda) {
                h.t = dist;
            } else {
                h.t.w = lambda;
                h.hit_vptr = indices.length() + 1;
                hit = true;
            }
        } else {
            if (intersectTriangle(origin,dir,h.hit_vptr,dist)) {
                h.t = dist;
            }
        }
    } else if (intersectGround(origin,dir,lambda)) {
        h.t.w = lambda;
        h.hit_vptr = indices.length() + 1;
        hit = true;
    }
    return hit;
}

const int MAX_TRACE = 1;

vec4 trace(vec4 origin, vec4 dir)
{
    // origin = eye.
    hitinfo_t inter;
    if(isIntersected(origin,dir,inter)){
        if (inter.hit_vptr < indices.length() + 1) {
            // Intersection avec un triangle
            vec3 pointInter = origin.xyz + inter.t.w*dir.xyz;
            vec3 toLightSource = normalize(lightPosition-pointInter);
            hitinfo_t t ;
            if (isIntersected(vec4(pointInter.xyz-0.001*dir.xyz,1),vec4(toLightSource,1),t)){
                // Eclairage ambiant
                vec4 color = interpolateColor(inter);
                return ambiant(color,0.5);
            } else {
                // Eclairage total
                // return vec4(1,0,0,1);
                vec4 color = interpolateColor(inter);
                vec4 normal = interpolateNormal(inter);
                vec4  Ca = ambiant(color,0.5);
                vec4 Cd = diffuse(color,normal,vec4(toLightSource,0),0.5);
                vec4 Cs = specular_blinn(color,normal,toLightSource,dir);
                // return  Ca + Cd;
                return Ca + Cd + Cs ;
            }
        } else if (inter.hit_vptr == indices.length() + 1) {
            // Intersection avec le sol
            vec3 pointInter = origin.xyz + inter.t.w * dir.xyz;
            vec3 toLightSource = normalize(lightPosition-pointInter);
            hitinfo_t t;
            if (isIntersected(vec4(pointInter.xyz-0.001*dir.xyz,1),vec4(toLightSource,1),t)){
                // Eclairage ambiant
                vec4 color = texture2D(colorTexture,vec2(pointInter.x/radius,pointInter.z/radius));
                return ambiant(color,0.5);
            } else {
                // Eclairage total
                // return vec4(1,0,0,1);
                vec4 color = texture2D(colorTexture,vec2(pointInter.x/radius,pointInter.z/radius));
                vec4 normal = vec4(0.0,1.0,0.0,0.0);
                vec4  Ca = ambiant(color,0.5);
                vec4 Cd = diffuse(color,normal,vec4(toLightSource,0),0.5);
                vec4 Cs = specular_blinn(color,normal,toLightSource,dir);
                // return  Ca + Cd;
                return Ca + Cd + Cs ;
            }
        }
    } else {
        return vec4(0.7,0.7,0.7,1.0);
    }
}

bool fillBouncesArray(vec4 origin, vec4 dir,out Pt_t inter ){
  hitinfo_t info;
  if(isIntersected(origin,dir,info)){
    inter.origin=origin;
    inter.dir=dir;
    inter.pt_hit = origin.xyz + info.t.w*dir.xyz;
    inter.normal = interpolateNormal(info);
    inter.color = trace(origin,dir);
    //TODO : Check le trace, on ne calcule pas l'orientation de la couleur ici à priori
    return true;
  }
  return false;
}

vec4 computeColor(in Pt_t tab[MAX_SCENE_BOUNDS]){
  int max_int = 0 ;
  vec4 color = vec4(0,0,0,0);
  while(tab[max_int].dir!=vec4(0,0,0,0)){
    max_int +=1;
  }
  if(max_int>0){
    max_int-=1;
    color = tab[max_int].color;
    float dist_x, dist_y, dist, F, cost;
    vec4 H ;
    vec3 toLightSource;
    while(max_int>0){
      max_int -=1;
      dist_x = tab[max_int].pt_hit.x-tab[max_int+1].pt_hit.x;
      dist_y = tab[max_int].pt_hit.y-tab[max_int+1].pt_hit.y;
      dist = sqrt(dist_x*dist_x + dist_y*dist_y);
      toLightSource = normalize(lightPosition-tab[max_int].pt_hit);
      H = vec4(normalize(toLightSource-reflect(tab[max_int].dir,tab[max_int].normal).xyz),1);
      cost = dot(H,vec4(toLightSource,1));
      F = fresnel_coeff(cost);
      color = F/(dist*dist) * color + tab[max_int].color;
    }
  }
  return color;
}

vec4 traceRays(vec4 origin, vec4 dir){
  Pt_t inter_array[MAX_SCENE_BOUNDS];
  Pt_t current;
  Pt_t null = {vec4(0,0,0,0),vec4(0,0,0,0),vec3(0,0,0),vec4(0,0,0,0),vec4(0,0,0,0)};
  for(int i = 0 ; i<MAX_SCENE_BOUNDS; i++){
    if(fillBouncesArray(origin,dir,current)){
      inter_array[i]=current;
      origin = vec4(current.pt_hit,1);
      dir = reflect(dir,current.normal);
    }else{
      // Si on n'a pas rebondi => on sort ! ( on remplit le tableau de points vides)
      while(i<MAX_SCENE_BOUNDS){
        inter_array[i]=null;
        i+=1;
      }
    }
  }
  // On a le tableau rempli, il faut déterminer la couleur
  return computeColor(inter_array);
}



layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
