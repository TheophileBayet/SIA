#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec4 Pmin = vec4(bbmin,1);
    vec4 Pmax = vec4(bbmax,1);
    vec4 tmin = Pmin - origin;
    tmin = tmin / dir;
    vec4 tmax = Pmax - origin;
    tmax = tmax / dir;
    vec4 minimum = min(tmax,tmin);
    vec4 maximum = max(tmax,tmin);
    float In = max(minimum.x,minimum.y);
    In = max(In,minimum.z);
    float Out = min(maximum.x,maximum.y);
    Out = min(Out,maximum.z);
    return (Out > In);
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
    vec4 e1 = vertices[indices[ptr+1]] - vertices[indices[ptr]] ;
    vec4 e2 = vertices[indices[ptr+2]] - vertices[indices[ptr]];
    vec4 t = origin - vertices[indices[ptr]];
    vec3 p_3 = cross(dir.xyz,e2.xyz);
    vec3 q_3 = cross(t.xyz,e1.xyz);
    vec4 p = vec4(p_3,0.0);
    vec4 q = vec4(q_3,0.0);
    float a = dot(p,e1);
    if (a > -EPS && a < EPS) {
        return false;
    }
    float coef = 1/a;
    float alpha = coef * dot(p,t);
    if (alpha < 0.0 || alpha > 1.0) {
        return false;
    }
    float beta = coef * dot(q,dir);
    if (beta < 0.0 || beta+alpha > 1.0) {
        return false;
    }
    float lambda = coef * dot(q,e2);
    if (10000.0 > lambda && lambda > EPS) {
        dist = vec4(alpha,beta,1-alpha-beta,lambda);
        return true;
    } else {
        return false;
    }
}

bool intersectGround(vec4 origin, vec4 dir, out float lambda) {
    vec4 normal = vec4(0.0,1.0,0.0,0.0);
    vec4 PQ = vec4(0.0,-groundDistance,0.0,1.0) - origin;
    float denom = dot(dir,normal);
    if (abs(denom) < EPS) {
        return false;
    }
    float lambda_temp = dot(PQ,normal) / denom;
    if (lambda_temp > EPS) {
        lambda = lambda_temp;
        return true;
    }
    lambda = 10000.0;
    return false;
}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    return vec4(1);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
	return vec4(1);
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
				// TODOtexture2DPro
			}
		}
	}
	return hit;
}

const int MAX_TRACE = 1;


vec4 trace(vec4 origin, vec4 dir)
{
	// TODO: trace a ray in the scene, see what it intersects, bounce around
    return vec4(1);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);


    vec4 dist;
    int nbr_triangle = indices.length() + 1;
    vec4 closest_triangle = vec4(0.0,0.0,0.0,10000.0);
    vec4 closest_color = vec4(0.0,0.0,0.0,1.0);
    float lambda;
    vec4 rouge;
    vec4 vert;

    if (intersectBoundingBox(eye,dir)) {
        for(int j = 0; j < indices.length(); j += 3) {
            if (intersectTriangle(eye,dir,j,dist)) {
                rouge = vec4(1.0,0.0,0.0,1.0);
                if (dist.w < closest_triangle.w) {
                    closest_triangle = dist;
                    closest_color = rouge;
                    nbr_triangle = j;
                }
            }
        }
        if (intersectGround(eye,dir,lambda)) {
            vec4 intersection = eye+lambda*dir;
            vert = texture2D(colorTexture,vec2(intersection.x,intersection.z));
            // vert = vec4(0.0,1.0,0.0,1.0);
            if (intersectTriangle(eye,dir,nbr_triangle,dist) && closest_triangle.w < lambda) {
                color = closest_color;
            } else {
                color = vert;
            }
        } else {
            if (intersectTriangle(eye,dir,nbr_triangle,dist)) {
                color = closest_color;
            } else {
                color = vec4(0.7,0.7,0.7,1.0);
            }
        }
    } else if (intersectGround(eye,dir,lambda)) {
        vec4 intersection = eye+lambda*dir;
        color = texture2D(colorTexture,vec2(intersection.x,intersection.z));
        // color = vec4(0.0,1.0,0.0,1.0);
    } else {
        color = vec4(0.7,0.7,0.7,1.0);
    }

    imageStore(framebuffer, pix, color);
}
