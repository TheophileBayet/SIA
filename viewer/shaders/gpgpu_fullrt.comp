#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform int refractions;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

struct Pt_t {
  vec4 origin;
  vec4 dir;
  vec3 pt_hit;
  vec4 normal;
  vec4 color;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

/*
* This function calculates the ambiant component of the Blinn-Phong model for lighting
*/
vec4 ambiant(vec4 color, float ka){
  return color*ka*lightIntensity;
}

/*
*This function calculates max(V1.V2,0), where V1 and V2 are both vec4 vectors.
*/

float max_scalar_zero(vec4 V1, vec4 V2) {
  float res = max(dot(V1,V2),0);
  return res;
}

/*
* This function calculates the diffuse component of the Blinn-Phong model for lighting
*/
vec4 diffuse(vec4 color,vec4 normal,vec4 LightVector, float kd){
  return color*max_scalar_zero(normal,LightVector)*kd*lightIntensity;
}

/*
* this function calculates the Fresnel coefficient
*/

float fresnel_coeff(float cost){
  float ci = abs(eta*eta + 1 - cost*cost) ;
  ci = sqrt(ci);
  float nume = cost - ci;
  float denom = cost + ci;
  float Fs = abs(nume/denom);
  Fs = Fs*Fs;
  nume = eta*eta*cost - ci;
  denom = eta*eta*cost + ci;
  float Fp = abs(nume/denom);
  Fp = Fp * Fp;
  return((Fs+Fp)/2);
  }


/*
* this function calculates the specular component of the Blinn-Phong model for ligthing
*/
vec4 specular_blinn(vec4 color, vec4 normal,vec3 toLightSource,vec4 direction){
  vec4 H = vec4(normalize(toLightSource-direction.xyz),1);
  float cost = dot(H,vec4(toLightSource,1));
  float F = fresnel_coeff(cost);
  float max = max_scalar_zero(normal,H);
  max = pow(max,shininess);
  return ( F*max* color *  lightIntensity);
}

bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec4 Pmin = vec4(bbmin,1);
    vec4 Pmax = vec4(bbmax,1);
    vec4 tmin = Pmin - origin;
    tmin = tmin / dir;
    vec4 tmax = Pmax - origin;
    tmax = tmax / dir;
    vec4 minimum = min(tmax,tmin);
    vec4 maximum = max(tmax,tmin);
    float In = max(minimum.x,minimum.y);
    In = max(In,minimum.z);
    float Out = min(maximum.x,maximum.y);
    Out = min(Out,maximum.z);
    return (Out > In);
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
    vec4 e1 = vertices[indices[ptr+1]] -vertices[indices[ptr]] ;
    vec4 e2 = vertices[indices[ptr+2]] - vertices[indices[ptr]];
    vec4 t = origin - vertices[indices[ptr]];
    vec3 p_3 = cross(dir.xyz,e2.xyz);
    vec3 q_3 = cross(t.xyz,e1.xyz);
    vec4 p = vec4(p_3,0.0);
    vec4 q = vec4(q_3,0.0);
    float a = dot(p,e1);
    if (a > -EPS && a < EPS) {
        return false;
    }
    float coef = 1/a;
    float alpha = coef * dot(p,t);
    if (alpha < 0.0 || alpha > 1.0) {
        return false;
    }
    float beta = coef * dot(q,dir);
    if (beta < 0.0 || beta+alpha > 1.0) {
        return false;
    }
    float lambda = coef * dot(q,e2);
    if (10000.0 > lambda && lambda > EPS) {
        dist = vec4(alpha,beta,1-alpha-beta,lambda);
        return true;
    } else {
        return false;
    }
}

bool intersectGround(vec4 origin, vec4 dir, out float lambda) {
    vec4 normal = vec4(0.0,1.0,0.0,0.0);
    vec4 PQ = vec4(0.0,-groundDistance,0.0,1.0) - origin;
    float denom = dot(dir,normal);
    if (abs(denom) < EPS) {
        return false;
    }
    float lambda_temp = dot(PQ,normal) / denom;
    if (lambda_temp > EPS) {
        lambda = lambda_temp;
        return true;
    }
    lambda = 10000.0;
    return false;
}

vec4 interpolateNormal(hitinfo_t h)
{
  vec4 n0 = normals[indices[h.hit_vptr]];
  vec4 n1 = normals[indices[h.hit_vptr+1]];
  vec4 n2 = normals[indices[h.hit_vptr+2]];
  return h.t.z*n0+h.t.x*n1+h.t.y*n2;

}

vec4 interpolateColor(hitinfo_t h)
{
  vec4 colV0 = colors[indices[h.hit_vptr]];
  vec4 colV1 = colors[indices[h.hit_vptr+1]];
  vec4 colV2 = colors[indices[h.hit_vptr+2]];
	return h.t.z*colV0+h.t.x*colV1+h.t.y*colV2;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
  vec4 dist; // stores distance + barycentric coord
	bool hit = false;
  vec4 normal ;
	h.t.w = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
        hit = true ;
        if(dist.w<h.t.w){
          h.t = dist;
          h.hit_vptr = j;
        }
			}
		}
	}
  // TODO : recherche intersection avec la texture.
	return hit;
}

const int MAX_TRACE = 1;

bool fillBouncesArray(vec4 origin, vec4 dir,out Pt_t inter ){
  hitinfo_t info;
  if(isIntersected(origin,dir,info)){
    inter.origin=origin;
    inter.dir=dir;
    inter.pt_hit = origin.xyz + info.t.w*dir.xyz;
    inter.normal = interpolateNormal(info);
    inter.color = interpolateColor(info);
    return true;
  }
  return false;
}

void traceRays(vec4 origin, vec4 dir){
  Pt_t inter_array[MAX_SCENE_BOUNDS];
  Pt_t current;
  for(int i = 0 ; i<MAX_SCENE_BOUNDS; i++){
    if(fillBouncesArray(origin,dir,current)){
      origin = vec4(current.pt_hit,1);
      dir = reflect(dir,current.normal);
    }else{
      // Si on a pas rebondi => on sort !
      break;
    }
  }
  // On a le tableau rempli, il faut dÃ©terminer la couleur

}

vec4 trace(vec4 origin, vec4 dir)
{
  // origin = eye.
  hitinfo_t inter ;
  if(isIntersected(origin,dir,inter)){
    // Intersection avec un triangle
    vec3 pointInter = origin.xyz + inter.t.w*dir.xyz;
    vec3 toLightSource = normalize(lightPosition-pointInter);
    hitinfo_t t ;
    if(isIntersected(vec4(pointInter.xyz-0.001*dir.xyz,1),vec4(toLightSource,1),t)){
      // Eclairage ambiant
      vec4 color = interpolateColor(inter);
      return ambiant(color,0.5);
    }else{
      // Eclairage total
      vec4 color = interpolateColor(inter);
      vec4 normal = interpolateNormal(inter);
      vec4  Ca = ambiant(color,0.5);
      vec4 Cd = diffuse(color,normal,vec4(toLightSource,0),0.5);
      vec4 Cs = specular_blinn(color,normal,toLightSource,dir);
      return Ca + Cd + Cs ;
    }
  }else{
    return vec4(0.7,0.7,0.7,1.0);
  }
}



layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);


    vec4 dist;
    float lambda;
    vec4 color1;
    vec4 color2;
    //
    // if (intersectBoundingBox(eye,dir)) {
    //     for(int j = 0; j < indices.length(); j += 3) {
    //         if (intersectTriangle(eye,dir,j,dist)) {
    //             color1 = vec4(1.0,0.0,0.0,1.0);
    //             if (intersectGround(eye,dir,lambda)) {
    //                 // color2 = texture2DProj(colorTexture,eye+lambda1*dir);
    //                 color2 = vec4(0.0,1.0,0.0,1.0);
    //                 if (lambda > dist.w) {
    //                     color = color1;
    //                 } else {
    //                     color = color2;
    //                 }
    //             } else {
    //                 color = color1;
    //             }
    //         } else if (intersectGround(eye,dir,lambda)) {
    //             color = vec4(0.0,1.0,0.0,1.0);
    //         } else {
    //             color = vec4(0.7,0.7,0.7,1.0);
    //         }
    //     }
    // } else if (intersectGround(eye,dir,lambda)) {
    //     color = vec4(0.0,1.0,0.0,1.0);
    //     // color2 = texture2DProj(colorTexture,eye+lambda1*dir);
    // } else {
    //     color = vec4(0.7,0.7,0.7,1.0);
    // }
    // vec4 intersection;
    // if (intersectGround(eye,dir,normal,intersection)) {
    //     color = texture2DProj(colorTexture,intersection);
    // }
    // for(int j = 0; j < indices.length(); j += 3) {
    //     if (intersectTriangle(eye,dir,j,dist)) {
    //         color = vec4(1.0,0.0,0.0,1.0);
    //     } else {
    //         color = vec4(0.7,0.7,0.7,1.0);
    //     }
    // }

    imageStore(framebuffer, pix, color);
}
